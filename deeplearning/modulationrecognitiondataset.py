#https://github.com/hhhhhhdb/OFDM-OTFS-modulation-recognition/tree/main
import os 
import os.path as osp 
import numpy as np
from scipy.io import loadmat
import gc
from typing import Tuple
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.utils.data import dataloader,random_split
import numpy as np
from tqdm import tqdm

class Dataset():
    """
    Reads OFDM modulated signal data generated by real devices (HackRF) and packages them into the dataset.
    """
    
    
    
    def __init__(self, basedir, dir1='BPSK', dir2='QPSK', filename1="BPSK.mat",filename2="QPSK.mat",filename3="8PSK.mat",filename4="16QAM.mat",filename5="64QAM.mat"):
        self.filename1=filename1
        self.filename2=filename2
        self.filename3=filename3
        self.filename4=filename4
        self.filename5=filename5
        
        self.path1=osp.join(basedir, dir1, self.filename1)
        self.path2=osp.join(basedir, dir1, self.filename2)
        self.path3=osp.join(basedir, dir1, self.filename3)
        self.path4=osp.join(basedir, dir1, self.filename4)
        self.path5=osp.join(basedir, dir1, self.filename5)

        self.path6=osp.join(basedir, dir2, self.filename1)
        self.path7=osp.join(basedir, dir2, self.filename2)
        self.path8=osp.join(basedir, dir2, self.filename3)
        self.path9=osp.join(basedir, dir2, self.filename4)
        self.path10=osp.join(basedir, dir2, self.filename5)



        self.X, self.label = self.load_data() #(300000, 2, 1024)
        self.modulations={
        "['BPSK_BPSK']":0,
        "['BPSK_QPSK']":1,
        "['BPSK_8PSK']":2,
        "['BPSK_16QAM']":3,
        "['BPSK_64QAM']":4,
        "['QPSK_BPSK']":5,
        "['QPSK_QPSK']":6,
        "['QPSK_8PSK']":7,
        "['QPSK_16QAM']":8,
        "['QPSK_64QAM']":9
    }
    
        gc.collect()

    def load_data(self):
        #BPSK_
        data_bpsk=loadmat(self.path1)
        data_bpsk=data_bpsk['data'] #30000 size array
        
        data_qpsk=loadmat(self.path2)
        data_qpsk=data_qpsk['data']

        data_8psk=loadmat(self.path3)
        data_8psk=data_8psk['data']

        data_16qam=loadmat(self.path4)
        data_16qam=data_16qam['data']

        data_64qam=loadmat(self.path5)
        data_64qam=data_64qam['data']

        #QPSK_
        data_qpsk_bpsk=loadmat(self.path6)
        data_qpsk_bpsk=data_qpsk_bpsk['data']

        data_qpsk_qpsk=loadmat(self.path7)
        data_qpsk_qpsk=data_qpsk_qpsk['data']

        data_qpsk_8psk=loadmat(self.path8)
        data_qpsk_8psk=data_qpsk_8psk['data']

        data_qpsk_16qam=loadmat(self.path9)
        data_qpsk_16qam=data_qpsk_16qam['data']

        data_qpsk_64qam=loadmat(self.path10)
        data_qpsk_64qam=data_qpsk_64qam['data']









        X,label=[],[]
        for i in range(30000):
            data=data_bpsk[0][i][0][0] #array([[array([[array([[ (2, 1024)
            data=torch.FloatTensor(data) #torch.Size([2, 1024])
            data=data.unsqueeze(0) #torch.Size([1, 2, 1024])
            X.append(data)
            lab=data_bpsk[0][i][1][0]
            lab=str(lab) #"['BPSK_BPSK']"
            label.append(lab)
        #[1][4] must be 0.
        #[2] represents represents the number of samples taken, the range is 0 - the number of samples.
        #[3] represents the removed label or data, range 0-1 (0 for data, 1 for label).

        
        for i in range(30000):
            data=data_qpsk[0][i][0][0] #2,1024
            data=torch.FloatTensor(data)
            data=data.unsqueeze(0) #torch.Size([1, 2, 1024])
            X.append(data)
            lab=data_qpsk[0][i][1][0] #['BPSK_QPSK']
            lab=str(lab)
            label.append(lab)
        

        for i in range(30000):
            data=data_8psk[0][i][0][0]
            data=torch.FloatTensor(data)
            data=data.unsqueeze(0)
            X.append(data)
            lab=data_8psk[0][i][1][0] #['BPSK_8PSK']
            lab=str(lab)
            label.append(lab)
        
        
        for i in range(30000):
            data=data_16qam[0][i][0][0] #(2, 1024)
            data=torch.FloatTensor(data)
            data=data.unsqueeze(0)
            X.append(data)
            lab=data_16qam[0][i][1][0]
            lab=str(lab) #"['BPSK_16QAM']"
            label.append(lab)
        


        for i in range(30000):
            data=data_64qam[0][i][0][0]
            data=torch.FloatTensor(data)
            data=data.unsqueeze(0)
            X.append(data)
            lab=data_64qam[0][i][1][0]
            lab=str(lab) #"['BPSK_64QAM']"
            label.append(lab)

        for i in range(30000):
            data=data_qpsk_bpsk[0][i][0][0]
            data=torch.FloatTensor(data)
            data=data.unsqueeze(0)
            X.append(data)
            lab=data_qpsk_bpsk[0][i][1][0]
            lab=str(lab) #"['QPSK_BPSK']"
            label.append(lab)
        
        

        for i in range(30000):
            data=data_qpsk_qpsk[0][i][0][0]
            data=torch.FloatTensor(data)
            data=data.unsqueeze(0)
            X.append(data)
            lab=data_qpsk_qpsk[0][i][1][0]
            lab=str(lab) #"['QPSK_QPSK']"
            label.append(lab)
        
        
        for i in range(30000):
            data=data_qpsk_8psk[0][i][0][0]
            data=torch.FloatTensor(data)
            data=data.unsqueeze(0)
            X.append(data)
            lab=data_qpsk_8psk[0][i][1][0]
            lab=str(lab) #"['QPSK_8PSK']"
            label.append(lab)
        
        
        for i in range(30000):
            data=data_qpsk_16qam[0][i][0][0]
            data=torch.FloatTensor(data)
            data=data.unsqueeze(0)
            X.append(data)
            lab=data_qpsk_16qam[0][i][1][0]
            lab=str(lab) #"['QPSK_16QAM']"
            label.append(lab)
        
        
        for i in range(30000):
            data=data_qpsk_64qam[0][i][0][0]
            data=torch.FloatTensor(data)
            data=data.unsqueeze(0)
            X.append(data)
            lab=data_qpsk_64qam[0][i][1][0]
            lab=str(lab) #"['QPSK_64QAM']"
            label.append(lab)
        
        

        
        
        X = np.vstack(X) #30000*10 size array, each with [1, 2, 1024] -> (300000, 2, 1024)
        return X,label
    def __getitem__(self, idx: int) -> Tuple[torch.Tensor, torch.Tensor]:
        x=self.X[idx] #(300000, 2, 1024) -> (2, 1024)
        mod=self.label[idx] #"['BPSK_8PSK']"
        label = self.modulations[mod] #2
        x= torch.FloatTensor(x)
        label=torch.tensor(label, dtype=torch.long)
        x=x.unsqueeze(0) #[1, 2, 1024]
        return x,label
    def __len__(self) -> int:
        return self.X.shape[0]


if __name__ == '__main__':
    basedir="D:\\Dataset\\CommunicationDataset\\OFDMOTFSDataset"
    basedir = os.path.join(basedir, 'real_channel_OFDM')
    dataset=Dataset(basedir=basedir)
    total=len(dataset) #300000
    split_train=0.6
    split_val=0.3
    batch_size=256
    length=[int(total*split_train)] #[180000, 90000, 30000]
    length.append(int(total*split_val))
    length.append(total-length[0]-length[1])
    print("Splitting into {} train and {} val and {} test".format(length[0], length[1],length[2]))
    train_set,val_set,test_set=random_split(dataset,length)
    
    train_loader=dataloader.DataLoader(dataset=train_set,batch_size=batch_size,shuffle=True)
    val_loader=dataloader.DataLoader(dataset=val_set,batch_size=batch_size,shuffle=True)
    test_loader=dataloader.DataLoader(dataset=test_set,batch_size=batch_size,shuffle=True)

    for i,(data,label) in enumerate(tqdm(train_loader)):
        print(data)
        print(label)